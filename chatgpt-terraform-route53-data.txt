

Below is **Module Version-1**, built exactly for your requirement:

### ‚úîÔ∏è Works for

* EC2
* ALB / NLB
* API Gateway
* CloudFront
* RDS endpoints
* Any normal or alias Route53 record

### ‚úîÔ∏è Supports

* A/AAAA/CNAME/TXT/MX/SRV/NS records
* Alias records
* Optional automatic import helper
* Clean variable structure

---

# ‚úÖ **MODULE STRUCTURE (Version-1)**

```
route53-record-module/
‚îú‚îÄ‚îÄ main.tf
‚îú‚îÄ‚îÄ variables.tf
‚îî‚îÄ‚îÄ outputs.tf
```

---

# üü¶ **main.tf**

```hcl
# ---------------------------------------------------------
# Route53 Record - Create or Update (after import)
# ---------------------------------------------------------

resource "aws_route53_record" "this" {
  zone_id = var.zone_id
  name    = var.name
  type    = var.type

  # For non-alias records
  ttl     = var.alias == null ? var.ttl : null
  records = var.alias == null ? var.records : null

  # For alias targets (ALB, NLB, CF, API GW)
  dynamic "alias" {
    for_each = var.alias == null ? [] : [var.alias]

    content {
      name                   = alias.value.name
      zone_id                = alias.value.zone_id
      evaluate_target_health = alias.value.evaluate_target_health
    }
  }
}

# ---------------------------------------------------------
# Optional - Helper to detect if record exists in AWS
# ---------------------------------------------------------
data "aws_route53_zone" "selected" {
  zone_id = var.zone_id
}

data "aws_route53_record" "existing" {
  count   = var.enable_existing_check ? 1 : 0
  zone_id = var.zone_id
  name    = var.name
  type    = var.type
}

# ---------------------------------------------------------
# Optional - Local command for auto-import
# User must run: terraform apply -auto-approve
# ---------------------------------------------------------
resource "null_resource" "auto_import" {
  count = var.enable_auto_import && length(data.aws_route53_record.existing) > 0 ? 1 : 0

  provisioner "local-exec" {
    command = <<EOF
    echo "Importing Route53 record..."
    terraform import aws_route53_record.this ${data.aws_route53_record.existing[0].id} || true
EOF
  }

  depends_on = [data.aws_route53_record.existing]
}
```

---

# üü¶ **variables.tf**

```hcl
variable "zone_id" {
  type        = string
  description = "Route53 Hosted Zone ID"
}

variable "name" {
  type        = string
  description = "Record name (e.g. app.example.com)"
}

variable "type" {
  type        = string
  description = "Record type (A, AAAA, CNAME, TXT, etc)"
}

variable "ttl" {
  type        = number
  default     = 60
  description = "TTL value for non-alias records"
}

variable "records" {
  type        = list(string)
  default     = []
  description = "Record values for non-alias records"
}

variable "alias" {
  description = "Alias record details"
  type = object({
    name                   = string
    zone_id                = string
    evaluate_target_health = optional(bool, false)
  })
  default = null
}

variable "enable_existing_check" {
  description = "Enable lookup for existing Route53 record"
  type        = bool
  default     = false
}

variable "enable_auto_import" {
  description = "Enable automatic terraform import for existing records"
  type        = bool
  default     = false
}
```

---

# üü¶ **outputs.tf**

```hcl
output "record_fqdn" {
  value = aws_route53_record.this.fqdn
}

output "record_id" {
  value = aws_route53_record.this.id
}
```

---

# üìò **HOW TO USE THE MODULE**

## 1Ô∏è‚É£ **Example: A Record for EC2**

```hcl
module "app_dns" {
  source = "./route53-record-module"

  zone_id = "Z034567ABCDE"
  name    = "app.dev.example.com"
  type    = "A"
  ttl     = 60

  records = ["10.0.20.50"]

  enable_existing_check = true
  enable_auto_import    = true
}
```

---

## 2Ô∏è‚É£ **Example: Alias Record for ALB**

```hcl
module "alb_dns" {
  source = "./route53-record-module"

  zone_id = "Z034567ABCDE"
  name    = "web.example.com"
  type    = "A"

  alias = {
    name                   = aws_lb.app_lb.dns_name
    zone_id                = aws_lb.app_lb.zone_id
    evaluate_target_health = true
  }

  enable_existing_check = true
  enable_auto_import    = true
}
```

---

## 3Ô∏è‚É£ **Example: API Gateway**

```hcl
module "api_dns" {
  source = "./route53-record-module"

  zone_id = "Z034567ABCDE"
  name    = "api.example.com"
  type    = "A"

  alias = {
    name    = aws_apigatewayv2_api.myapi.api_endpoint
    zone_id = aws_apigatewayv2_domain_name.my_domain.hosted_zone_id
  }

  enable_existing_check = true
  enable_auto_import    = true
}
```

---

# üìò **Example: What Happens with Auto-Import**

### If AWS already has record:

```
app.dev.example.com already exists
module auto-import runs:
terraform import aws_route53_record.this Z03456ABCDE_app.dev.example.com_A
```

Then Terraform updates the record going forward.

### If record does not exist:

```
Terraform will create it normally
```

---

# üü© Module v1 Ready

If you want, I can also provide:

‚úîÔ∏è Module v2 ‚Äì with validation + default patterns
‚úîÔ∏è Module v3 ‚Äì with multi-record set support
‚úîÔ∏è Examples for ALB, NLB, S3 Static Website, CloudFront

Just tell me **‚Äúgive v2‚Äù** or **‚Äúgive v3‚Äù**.


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Below is **Module Version-2**, improved from v1 with:

### ‚úîÔ∏è New Features in v2

* Validation for record names, TTL, types
* Multi-record support (multiple A/AAAA/TXT values)
* Better alias validation
* Conditional creation of alias vs normal record
* Simpler auto-import workflow
* Cleaner variable defaults
* Better error messages

### ‚úîÔ∏è Purpose of v2

To create a **production-grade Route53 record module** that works for:

* EC2
* ALB / NLB
* API Gateway
* CloudFront
* RDS
* Lambdas + Function URLs
* Anything using Route53 records

---

# üìÅ **Directory Structure**

```
route53-record-module-v2/
‚îú‚îÄ‚îÄ main.tf
‚îú‚îÄ‚îÄ variables.tf
‚îî‚îÄ‚îÄ outputs.tf
```

---

# üü¶ **main.tf (v2)**

```hcl
###############################################
# Route53 Record Management (Supports Alias)
###############################################

locals {
  is_alias = var.alias != null
}

resource "aws_route53_record" "this" {
  zone_id = var.zone_id
  name    = var.name
  type    = var.type

  # Non-alias record
  ttl     = local.is_alias ? null : var.ttl
  records = local.is_alias ? null : var.records

  # Alias record
  dynamic "alias" {
    for_each = local.is_alias ? [var.alias] : []

    content {
      name                   = alias.value.name
      zone_id                = alias.value.zone_id
      evaluate_target_health = alias.value.evaluate_target_health
    }
  }
}

###############################################
# OPTIONAL: Auto-import existing record
###############################################

data "aws_route53_record" "existing" {
  count   = var.enable_auto_import ? 1 : 0
  zone_id = var.zone_id
  name    = var.name
  type    = var.type
}

resource "null_resource" "import_record" {
  count = var.enable_auto_import && length(data.aws_route53_record.existing) > 0 ? 1 : 0

  provisioner "local-exec" {
    command = "terraform import aws_route53_record.this ${data.aws_route53_record.existing[0].id} || true"
  }
}
```

---

# üü¶ **variables.tf (v2)**

```hcl
###################################################
# Required variables
###################################################

variable "zone_id" {
  description = "Route53 Hosted Zone ID"
  type        = string

  validation {
    condition     = length(var.zone_id) > 0
    error_message = "zone_id cannot be empty."
  }
}

variable "name" {
  description = "DNS record name"
  type        = string

  validation {
    condition     = can(regex("^[a-zA-Z0-9.-]+$", var.name))
    error_message = "Record 'name' contains invalid characters."
  }
}

variable "type" {
  description = "DNS record type"
  type        = string

  validation {
    condition     = contains(["A", "AAAA", "CNAME", "TXT", "MX", "SRV", "NS"], var.type)
    error_message = "Supported types: A, AAAA, CNAME, TXT, MX, SRV, NS"
  }
}

###################################################
# Optional variables
###################################################

variable "ttl" {
  description = "TTL for non-alias records"
  type        = number
  default     = 60

  validation {
    condition     = var.ttl >= 1 && var.ttl <= 86400
    error_message = "TTL must be between 1 and 86400 seconds."
  }
}

variable "records" {
  description = "List of values for non-alias records"
  type        = list(string)
  default     = []
}

variable "alias" {
  description = "Alias configuration (ALB/NLB/API GW/CloudFront)"
  type = object({
    name                   = string
    zone_id                = string
    evaluate_target_health = optional(bool, false)
  })
  default = null

  validation {
    condition     = var.alias == null || (length(var.alias.name) > 0 && length(var.alias.zone_id) > 0)
    error_message = "Alias requires 'name' and 'zone_id' fields."
  }
}

variable "enable_auto_import" {
  description = "Import existing Route53 record automatically"
  type        = bool
  default     = false
}
```

---

# üü¶ **outputs.tf (v2)**

```hcl
output "record_fqdn" {
  value = aws_route53_record.this.fqdn
}

output "record_id" {
  value = aws_route53_record.this.id
}

output "is_alias_record" {
  value = var.alias != null
}
```

---

# ‚≠ê **V2 Usage Examples (With Data + Diagrams)**

(You asked to provide examples with data + images/diagrams ‚Äî I‚Äôll include the diagrams in ASCII form.)

---

# üîµ **1. EC2 A Record Example**

```hcl
module "ec2_dns" {
  source = "./route53-record-module-v2"

  zone_id = "Z0562345ABCDEF"
  name    = "backend.dev.example.com"
  type    = "A"

  ttl     = 60
  records = ["10.10.1.25"]

  enable_auto_import = true
}
```

### **Flow (ASCII Diagram)**

```
EC2 Private IP ‚Üí Route53 A Record
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ   EC2 Node   ‚îÇ
       ‚îÇ 10.10.1.25   ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚îÇ DNS Mapping
               ‚ñº
 backend.dev.example.com
```

---

# üîµ **2. ALB Alias Record Example**

```hcl
module "alb_dns" {
  source = "./route53-record-module-v2"

  zone_id = "Z0562345ABCDEF"
  name    = "app.example.com"
  type    = "A"

  alias = {
    name                   = aws_lb.app.dns_name
    zone_id                = aws_lb.app.zone_id
    evaluate_target_health = true
  }

  enable_auto_import = true
}
```

### **Flow Diagram**

```
app.example.com
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  AWS ALB    ‚îÇ
‚îÇ dns: xyz... ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

# üîµ **3. API Gateway Alias Example**

```hcl
module "api_dns" {
  source = "./route53-record-module-v2"

  zone_id = "Z0562345ABCDEF"
  name    = "api.example.com"
  type    = "A"

  alias = {
    name    = aws_apigatewayv2_domain_name.api.domain_name_configuration[0].target_domain_name
    zone_id = aws_apigatewayv2_domain_name.api.domain_name_configuration[0].hosted_zone_id
  }

  enable_auto_import = true
}
```

---

# üîµ **4. Multiple TXT Records**

```hcl
module "txt_records" {
  source = "./route53-record-module-v2"

  zone_id = "Z0562345ABCDEF"
  name    = "example.com"
  type    = "TXT"

  records = [
    "v=spf1 include:mail.example.com",
    "google-site-verification=abcd12345"
  ]

  enable_auto_import = true
}
```

---

# üü© v2 is Ready

If you want, I can now create:

### üî• Module v3

* Create/update/delete multiple records in one call
* Wildcard record support
* Weighted/Latency/Failover routing
* Health check integration
* Loop-based multi-record creation (list of maps)
* Mapping for RDS / NLB / CloudFront
* Optional TTL override rules

Just say: **give v3**.



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Below is **Module Version-3**, a **full production-grade Route53 module** that supports:

---

# üöÄ **NEW FEATURES in v3 (Major Upgrade)**

### ‚úîÔ∏è 1. **Multi-record support (create many records at once)**

Input format:

```hcl
records = [
  {
    name = "app.dev.example.com"
    type = "A"
    ttl  = 60
    values = ["10.0.0.5"]
  },
  {
    name = "api.dev.example.com"
    type = "CNAME"
    values = ["myapi.cloudfront.net"]
  }
]
```

### ‚úîÔ∏è 2. **Supports Alias records inside list**

```hcl
alias = {
   name    = "xxxx.elb.amazonaws.com"
   zone_id = "Z12345"
}
```

### ‚úîÔ∏è 3. **Supports Weighted, Failover, Latency routing**

Per-record level:

* `routing_policy = "weighted"`
* `set_identifier = "app-west"`
* `weight = 100`

### ‚úîÔ∏è 4. **Supports Health checks**

```
health_check_id = aws_route53_health_check.app.id
```

### ‚úîÔ∏è 5. **Wildcard records**

```
name = "*.example.com"
```

### ‚úîÔ∏è 6. **Automatic import per record**

If a record exists ‚Üí auto-import and update.

### ‚úîÔ∏è 7. **Smart detection: alias vs non-alias**

---

# üìÅ **Module Structure**

```
route53-record-module-v3/
‚îú‚îÄ‚îÄ main.tf
‚îú‚îÄ‚îÄ variables.tf
‚îî‚îÄ‚îÄ outputs.tf
```

---

# üü¶ **main.tf (v3)**

```hcl
#######################################################
# MULTIPLE ROUTE53 RECORDS HANDLER (v3)
#######################################################

locals {
  record_map = {
    for r in var.records : "${r.name}_${r.type}" => r
  }
}

resource "aws_route53_record" "records" {
  for_each = local.record_map

  zone_id         = var.zone_id
  name            = each.value.name
  type            = each.value.type
  ttl             = lookup(each.value, "ttl", null)
  set_identifier  = lookup(each.value, "set_identifier", null)
  health_check_id = lookup(each.value, "health_check_id", null)

  # Routing policies
  weight     = each.value.routing_policy == "weighted" ? lookup(each.value, "weight", null) : null
  latency_routing_region = each.value.routing_policy == "latency" ? lookup(each.value, "latency_region", null) : null
  failover   = each.value.routing_policy == "failover" ? lookup(each.value, "failover_type", null) : null

  # Non-alias records
  records = contains(keys(each.value), "alias") ? null : each.value.values

  # Alias record
  dynamic "alias" {
    for_each = contains(keys(each.value), "alias") ? [each.value.alias] : []

    content {
      name                   = alias.value.name
      zone_id                = alias.value.zone_id
      evaluate_target_health = lookup(alias.value, "evaluate_target_health", false)
    }
  }
}

#######################################################
# AUTO-IMPORT EXISTING RECORDS
#######################################################

data "aws_route53_record" "existing" {
  for_each = var.enable_auto_import ? local.record_map : {}

  zone_id = var.zone_id
  name    = each.value.name
  type    = each.value.type
}

resource "null_resource" "auto_import" {
  for_each = var.enable_auto_import ? data.aws_route53_record.existing : {}

  provisioner "local-exec" {
    command = <<EOF
      echo "Importing record: ${each.key}"
      terraform import aws_route53_record.records["${each.key}"] ${each.value.id} || true
EOF
  }

  depends_on = [data.aws_route53_record.existing]
}
```

---

# üü¶ **variables.tf (v3)**

```hcl
#############################################################
# REQUIRED INPUTS
#############################################################

variable "zone_id" {
  type        = string
  description = "Route53 Hosted Zone ID"
}

#############################################################
# MULTI RECORD INPUT
#############################################################

variable "records" {
  description = "List of Route53 records to create/update"
  type = list(
    object({
      name            = string
      type            = string
      values          = optional(list(string))
      ttl             = optional(number)
      alias           = optional(object({
        name                   = string
        zone_id                = string
        evaluate_target_health = optional(bool, false)
      }))
      # Advanced settings
      routing_policy  = optional(string) # weighted, latency, failover
      weight          = optional(number)
      latency_region  = optional(string)
      failover_type   = optional(string) # PRIMARY or SECONDARY
      set_identifier  = optional(string)
      health_check_id = optional(string)
    })
  )
}

#############################################################
# FLAGS
#############################################################

variable "enable_auto_import" {
  type    = bool
  default = false
  description = "Automatically import existing Route53 records"
}
```

---

# üü¶ **outputs.tf (v3)**

```hcl
output "records_ids" {
  value = {
    for k, v in aws_route53_record.records :
    k => v.id
  }
}

output "records_fqdns" {
  value = {
    for k, v in aws_route53_record.records :
    k => v.fqdn
  }
}
```

---

# ‚≠ê **USAGE EXAMPLES (V3)**

(With real data + diagrams)

---

# üîµ **1. Create multiple records at once**

```hcl
module "dns" {
  source = "./route53-record-module-v3"

  zone_id = "Z055ABCDEF"

  records = [
    {
      name   = "backend.dev.example.com"
      type   = "A"
      ttl    = 60
      values = ["10.0.1.20"]
    },
    {
      name   = "frontend.dev.example.com"
      type   = "CNAME"
      values = ["frontend.cloudfront.net"]
    }
  ]

  enable_auto_import = true
}
```

### Diagram

```
backend.dev ‚Üí 10.0.1.20
frontend.dev ‚Üí frontend.cloudfront.net
```

---

# üîµ **2. ALB Alias + Weighted Routing**

```hcl
records = [
  {
    name   = "app.example.com"
    type   = "A"
    alias = {
      name    = aws_lb.app.dns_name
      zone_id = aws_lb.app.zone_id
    }
    routing_policy = "weighted"
    weight         = 100
    set_identifier = "app-alb-blue"
  }
]
```

Diagram:

```
app.example.com
       ‚Üì (Weighted 100)
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ   ALB    ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

# üîµ **3. Failover Setup (Primary + Secondary)**

```hcl
records = [
  {
    name   = "db.example.com"
    type   = "CNAME"
    values = ["db-primary.rds.amazonaws.com"]
    routing_policy = "failover"
    failover_type  = "PRIMARY"
    set_identifier = "primary-db"
  },
  {
    name   = "db.example.com"
    type   = "CNAME"
    values = ["db-standby.rds.amazonaws.com"]
    routing_policy = "failover"
    failover_type  = "SECONDARY"
    set_identifier = "secondary-db"
  }
]
```

Diagram:

```
db.example.com ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ PRIMARY (active)
                     ‚ñº
                    RDS
                    Standby (failover)
```

---

# üîµ **4. Latency-based Routing**

```hcl
records = [
  {
    name   = "service.example.com"
    type   = "A"
    values = ["10.0.0.10"]
    routing_policy = "latency"
    latency_region = "us-east-1"
    set_identifier = "east"
  }
]
```

---

# üîµ **5. Wildcard Record**

```hcl
records = [
  {
    name   = "*.example.com"
    type   = "A"
    values = ["10.20.30.40"]
  }
]
```

---

# üü© v3 Completed

This is a **fully enterprise**, multi-record, multi-routing, alias/non-alias, auto-import capable module.

If you want **v4**, I can add:

### üî• v4 Feature Options

* Create/delete based on conditions
* Multi-zone support
* Reverse DNS PTR records
* ACM validation automation
* Subdomain automated creation
* JSON-based input schema
* Outputs formatted as tables

Just say **"give v4"**.
